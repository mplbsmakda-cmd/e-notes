/**
 * Core Philosophy: This ruleset supports a hybrid data model. User-specific data like profiles, categories, and tags
 * are siloed under a user's ID for strict privacy. Collaborative data, primarily notes, are in a root collection
 * with access controlled by a permissions system within each document.
 *
 * Data Structure:
 * - /users/{userId}: Private user data (profile, categories, tags). Access is based on path ownership.
 * - /notes/{noteId}: Collaborative notes. Access is determined by `_canAccess` and `permissions` fields in the document.
 * - /sharedNotes/{sharedNoteId}: Publicly accessible, single-use sharing links.
 *
 * Key Security Decisions:
 * - User-Siloed Data: Access to anything under `/users/{userId}` is strictly limited to the user whose UID matches `{userId}`.
 * - Note Access Control: Access to `/notes/{noteId}` is governed by document data.
 *   - Read access ('get') is granted if a user's UID is in the `_canAccess` array.
 *   - List access for queries is implicitly granted if the query constraints ensure that every potential document in the result set would pass the 'get' rule. This is why client-side queries MUST filter by `_canAccess`.
 *   - Write access is granted if the user's role in the `permissions` map is 'owner' or 'editor'.
 *   - Deletion is restricted to the 'owner'.
 * - Secure Sharing: `sharedNotes` creation is restricted to the owner of the target note, verified with a `get()` call.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function hasMatchingUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    function hasMatchingOwnerIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    function isUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    function isOwnerIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    match /users/{userId} {
      allow get, update, delete: if isOwner(userId);
      allow create: if isOwner(userId) && hasMatchingOwnerIdOnCreate(userId);
      allow list: if false; // Disable user enumeration

      match /categories/{categoryId} {
        allow get, list, delete: if isOwner(userId);
        allow create: if isOwner(userId) && hasMatchingUserIdOnCreate(userId);
        allow update: if isOwner(userId) && isUserIdImmutable();
      }

      match /tags/{tagId} {
        allow get, list, delete: if isOwner(userId);
        allow create: if isOwner(userId) && hasMatchingUserIdOnCreate(userId);
        allow update: if isOwner(userId) && isUserIdImmutable();
      }
    }

    /**
     * @description Manages notes, which can be shared among users.
     * @path /notes/{noteId}
     * @allow (get) Any user in the note's `_canAccess` array can read it.
     * @allow (list) Implicitly allowed if the query is constrained to documents where the user has 'get' access.
     * @allow (create) A new note must assign the creator as the owner.
     * @allow (update) Users with 'owner' or 'editor' roles can update the note.
     * @allow (delete) Only the 'owner' can delete the note.
     * @principle Implements document-level security for collaborative data.
     */
    match /notes/{noteId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data._canAccess && resource.data.destructAt > request.time;
      // List operations are secured by the 'get' rule. Client-side queries MUST filter
      // by '_canAccess' to ensure only authorized documents are requested.
      allow create: if isSignedIn() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.permissions[request.auth.uid] == 'owner' &&
                       request.auth.uid in request.resource.data._canAccess &&
                       'destructAt' in request.resource.data;
      allow update: if isSignedIn() && resource.data.permissions[request.auth.uid] in ['owner', 'editor'] && resource.data.destructAt > request.time;
      allow delete: if isSignedIn() && resource.data.permissions[request.auth.uid] == 'owner' && resource.data.destructAt > request.time;
    }
    
    /**
     * @description Manages one-time shareable links for notes.
     * @path /sharedNotes/{sharedNoteId}
     * @allow (get) Anyone with the link ID can read it.
     * @allow (create) Only the note's owner can create a share link.
     * @allow (update) Anyone can mark a link as used, but not un-use it.
     * @principle Allows secure, one-time sharing without exposing user data.
     */
    match /sharedNotes/{sharedNoteId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() &&
                       request.resource.data.userId == request.auth.uid &&
                       get(/databases/$(database)/documents/notes/$(request.resource.data.noteId)).data.ownerId == request.auth.uid;
      allow update: if request.resource.data.isUsed == true && resource.data.isUsed == false;
      allow delete: if false;
    }
  }
}
